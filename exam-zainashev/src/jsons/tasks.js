export default [
  {
    "id": "61209cdd780b438a6a3a6722",
    "name": "Создание проекта курса в Трелло. Создание репозитория на GitHub. Файл ReadMe. Markdown язык разметки. Базовые команды Git. npm. Package.json. Создание проекта на stackblitz.com",
    "desc": "###Материалы лекций:\n\n- https://metanit.com/web/react/1.1.php\n- https://ru.reactjs.org/tutorial/tutorial.html\n\n###Топ-10 библиотек для React на GitHub\n- https://habr.com/ru/company/ruvds/blog/345060/\n\n##Как работает stackblitz.com?\n\nВы можете открыть любой публичный репозиторий на Github, указав имя пользователя + имя репозитория:\n\n> stackblitz.com/github/{ИМЯ_ПОЛЬЗОВАТЕЛЯ}/{РЕПОЗИТОРИЙ}\n\nКроме того, вы также можете указать ветку, тэг или коммит:\n\n> stackblitz.com/GitHub/{ИМЯ_ПОЛЬЗОВАТЕЛЯ}/{РЕПОЗИТОРИЙ}/tree/{ТЭГ|ВЕТКА|КОММИТ}\n\n##Загрузка за считанные секунды\n\nБольше не нужна загрузка, клонирование или установка. Благодаря Turbo package manager StackBlitz установит все зависимости и загрузит ваше приложение за считаные секунды.\n\n##Редактирование «живого» кода в реальной среде\n\nStackBlitz идет «из коробки» со всеми функциональными возможностями, которые есть в вашей локальной версии VS Code, например: intellisense, go to definition, hot reloading, полный доступ к npm и многое другое.\n",
    "idShort": 1,
    "shortLink": "b7Oah6i8"
  },
  {
    "id": "6120f580571a96541c653c32",
    "name": "Создание React-приложения. Установка расширения React Developer Tools. Введение в React. Виртуальный DOM. Основы JSX.",
    "desc": "##Схема сборки по каталогам простого Реакт прилодения\n\n```\n@startuml packaging\ncomponent \"Create-project-app\" as project  {\n\n    folder \"/node_modues\" {\n        artifact \"/...\" as node_modules\n    }\n    folder \"/src\" {\n        artifact \"/...\" as src\n    }\n    folder \"/public/...\" as public {\n        file \"/index.html\" as public_index\n        file \"/favicon.ico\" as public_favicon\n        file \"/manifest.json\" as public_manifest\n    }\n}\n\ncloud {\n    card \"localhost:3000\" {\n        file \"manifest.json\" as manifest\n        file \"main.chunk.js\" as main\n        file \"favicon.ico\" as favicon\n        file \"vendor~main.chunk.js\" as vendor\n        file \"bundle.js\" as bundle\n\n        node_modules --> vendor\n        src --> main\n        public_favicon --> favicon\n        public_manifest --> manifest\n\n        artifact \"index.html\" as index {\n            public_index --> index\n            manifest --> index\n            main --> index\n            favicon --> index\n            vendor --> index\n            bundle -r-> index\n        }\n    }\n}\n@enduml\n```",
    "idShort": 2,
    "shortLink": "IAHqXnwx"
  },
  {
    "id": "612a93fc3354858e3462d4c7",
    "name": "Рендеринг элементов. Компоненты и пропсы.",
    "desc": "#Материалы\n\nhttps://ru.reactjs.org/docs/rendering-elements.html\nhttps://ru.reactjs.org/docs/components-and-props.html\nhttps://metanit.com/web/react/2.1.php\nhttps://metanit.com/web/react/2.2.php\nhttps://metanit.com/web/react/2.3.php\n\n###PS:\nПроекты сдаём с набором инструментов интерфейса: https://blueprintjs.com/ (есть и другие: https://habr.com/ru/company/ruvds/blog/345060/)\n",
    "idShort": 3,
    "shortLink": "PtRhZXlP"
  },
  {
    "id": "612a95809677848ef97025ec",
    "name": "Обработка событий и состояние компонента",
    "desc": "#Материалы\n\n- https://ru.reactjs.org/docs/state-and-lifecycle.html\n- https://ru.reactjs.org/docs/handling-events.html\n\n---\n\n- https://metanit.com/web/react/2.4.php\n- https://metanit.com/web/react/2.5.php\n\n---\n- https://learn.javascript.ru/screencast/react#react-data-for-component\n- https://learn.javascript.ru/screencast/react#react-state\n",
    "idShort": 4,
    "shortLink": "pEubZDcS"
  },
  {
    "id": "613300ae050d62301d886d89",
    "name": "Жизненный цикл компонента",
    "desc": "#Материалы\n\nОчень простое домашнее задание разобрать примеры и добавить ссылки на стэкблицз.\n\n##Лукасы:\n\nhttps://www.youtube.com/embed/O8f6aXqpGHw\nhttps://www.youtube.com/embed/bMApsb0FpFE\n\n##Ридасы:\n\nhttps://metanit.com/web/react/2.6.php\nhttps://ru.reactjs.org/docs/react-component.html\nhttps://ru.reactjs.org/docs/state-and-lifecycle.html\nhttps://abcinblog.blogspot.com/2018/05/reactjs-6.html\nhttps://tproger.ru/translations/react-after-learning-basics/\n\n#React-Lifecycle-Diagram\n\n##Первый вариант:\n```\n@startuml\nskinparam rectangle {\nRoundCorner 20\nshadowing false\n}\n\nskinparam linetype polyline\nskinparam linetype ortho\nskinparam arrowThickness 4\nskinparam ArrowColor LightSkyBlue\n\nrectangle Монтирование {\n\nrectangle \"constructor(props)\" as con\nrectangle \"static getDerivedStateFromProps(props, state)\" as gdsfp1 #palegreen\nrectangle \"componentWillMount()\" as cwm #pink;line.dashed\nrectangle \"render()\" as ren #lightblue\nrectangle \"componentDidMount()\" as cdm\n\ncon --> gdsfp1\ngdsfp1 ----> cwm\ncwm --> ren\nren ---> cdm\n}\n\nrectangle Обновление {\n\nrectangle \"this.props\" as props #transparent;line:transparent\nrectangle \"setState()\" as state #transparent;line:transparent\nrectangle \"forceUpdate()\" as fu #transparent;line:transparent\nrectangle \" static getDerivedStateFromProps(props, state) \" as gdsfp #palegreen\nrectangle \"componentWillReceiveProps(nextProps)\" as cwrp #pink;line.dashed\nrectangle \"shouldComponentUpdate(nextProps, nextState)\" as scu\nrectangle \"❌    \" as cross #transparent;line:transparent;text:red\nrectangle \"componentWillUpdate(nextProps, nextState)\" as cwu #pink;line.dashed\nrectangle \" render() \" as r #lightblue\nrectangle \"getSnapshotBeforeUpdate(prevProps, prevState)\" as gsbu\nrectangle \"componentDidUpdate(prevProps, prevState, snapshot)\" as cdu\n\nprops -D-> gdsfp\nstate -D-> gdsfp\nfu -D-> gdsfp\ngdsfp --> cwrp\ncwrp --> scu\nscu -U---> cross : \"false         \"\nscu --> cwu : \" true\"\ncwu --> r\nr --> gsbu\ngsbu --> cdu\n}\n\nrectangle Размонтирование {\n\nrectangle empty #transparent;line:transparent;text:transparent\nrectangle \"componentWillUnmount()\" as cwum\n\nempty --------> cwum\n}\n\nrectangle \"Обработка ошибок\" {\n\nrectangle \"empty  \" as em #transparent;line:transparent;text:transparent\n\nrectangle \"static getDerivedStateFromError(error)\" as gdsfe\nrectangle \"componentDidCatch(error, info)\" as cdc\n\nem --> gdsfe\ngdsfe -------> cdc\n}\n\nrectangle \"Описание методов\" {\n\nrectangle \"constructor(props)\\nконструктор компонента React\" as conCom\nrectangle \"static getDerivedStateFromProps(props, state)\\nвызывается непосредственно\\nперед вызовом метода\\nrender, как при начальном монтировании,так\\nи при последующих обновлениях.\" as gdsfpCom #palegreen\nrectangle \"componentWillMount()\\nвызывается непосредственно\\n перед монтированием.\" as cwmCom #pink;line.dashed\nrectangle \"render()\\nединственный обязательный метод\\n в классовом компоненте.\" as renCom #lightblue\nrectangle \"componentDidMount()\\nвызывается сразу после\\n монтирования (то есть, вставки\\n компонента в DOM).\" as cdmCom\n\nrectangle \"componentWillReceiveProps(nextProps)\\nвызывается до того, как\\n смонтированный компонент\\n получит новые пропсы.\" as cwrpCom #pink;line.dashed\nrectangle \"Используйте shouldComponentUpdate(nextProps, nextState),\\n чтобы указать необходимость следующего\\n рендера на основе изменений\\n состояния и пропсов.\" as scuCom\nrectangle \"componentWillUpdate(nextProps, nextState)\\nвызывается непосредственно перед рендером\\n при получении новых пропсов или состояния.\" as cwuCom #pink;line.dashed\nrectangle \"getSnapshotBeforeUpdate(prevProps, prevState)\\nвызывается прямо перед\\n этапом «фиксирования» (например, перед\\n добавлением в DOM).\" as gsbuCom\nrectangle \"componentDidUpdate(prevProps, prevState, snapshot)\\nвызывается сразу после обновления.\" as cduCom\n\nrectangle \"componentWillUnmount()\\nвызывается непосредственно перед\\n размонтированием и удалением компонента.\" as cwumCom\n\nrectangle \"getDerivedStateFromError(error)\\nметод жизненного цикла\\n вызывается после возникновения\\n ошибки у компонента-потомка.\" as gdsfeCom\nrectangle \"componentDidCatch(error, info)\\nметод жизненного цикла\\n вызывается после возникновения\\n ошибки у компонента-потомка.\" as cdcCom\n\nconCom -[hidden]-> gdsfpCom\ngdsfpCom -[hidden]-> cwmCom\ncwmCom -[hidden]-> renCom\nrenCom -[hidden]-> cdmCom\ncdmCom -[hidden]-> cwrpCom\ncwrpCom -[hidden]-> scuCom\nscuCom -[hidden]-> cwuCom\nconCom -[hidden]> gsbuCom\ngsbuCom -[hidden]-> cduCom\ncduCom -[hidden]-> cwumCom\ncwumCom -[hidden]-> gdsfeCom\ngdsfeCom -[hidden]-> cdcCom\n\n}\n@enduml\n```\n\n##Второй вариант\n\n```\n@startuml\nskinparam rectangle {\nRoundCorner 20\nshadowing false\n}\n\nskinparam linetype polyline\nskinparam linetype ortho\nskinparam arrowThickness 6\nskinparam ArrowColor DarkGray\nskinparam defaultTextAlignment center\n\nrectangle \"constructor(props)\" as con\nrectangle \"static getDerivedStateFromProps(props, state)\" as gdsfp1 #palegreen\nrectangle \"componentWillMount()\" as cwm #pink;line.dashed\nrectangle \"render()\" as ren #lightblue\nrectangle \"componentDidMount()\" as cdm\nrectangle \"Running\\nthis.props, setState(), forceUpdate()\" as run #RoyalBlue;text:white\nrectangle \" Running \" as run1 #RoyalBlue;text:white\nrectangle \"  Running  \" as run2 #RoyalBlue;text:white\nrectangle \" static getDerivedStateFromProps(props, state) \" as gdsfp #palegreen\nrectangle \"componentWillReceiveProps(nextProps)\" as cwrp #pink;line.dashed\nrectangle \"shouldComponentUpdate(nextProps, nextState)\" as scu\nrectangle \" \" as space\nrectangle \"componentWillUpdate(nextProps, nextState)\" as cwu #pink;line.dashed\nrectangle \" render() \" as r #lightblue\nrectangle \"getSnapshotBeforeUpdate(prevProps, prevState)\" as gsbu\nrectangle \"componentDidUpdate(prevProps, prevState, snapshot)\" as cdu\nrectangle empty #transparent;line:transparent;text:transparent\nrectangle \"componentWillUnmount()\" as cwum\nrectangle \"empty  \" as em #transparent;line:transparent;text:transparent\nrectangle \"static getDerivedStateFromError(error)\" as gdsfe\nrectangle \"componentDidCatch(error, info)\" as cdc\n\ncon --> gdsfp1\ngdsfp1 --> cwm : \" deprecated\"\ncwm --> ren\nren --> cdm\ncdm --> run\nrun --> gdsfp : \" props changed\"\nrun --> scu : \"    state changed\"\ngdsfp --> cwrp : \"deprecated\"\ncwrp --> scu\nscu -R-> space : \"false\" do not update\nspace -U-> run\nscu --> cwu : \"  true\"\ncwu --> r\nr --> gsbu\ngsbu --> cdu : snapshot\ncdu -U-> space\n\nrun1 --> cwum : \" unmount\"\ncwum --> run2 #line:transparent\nrun2 --> gdsfe : \" child component error\"\ngdsfe --> cdc\n@enduml\n```\n",
    "idShort": 5,
    "shortLink": "nOx4Tq9r"
  },
  {
    "id": "61330e5ef4fb9674a9c2fac4",
    "name": "Управление ресурсами. Условный рендеринг",
    "desc": "Управление ресурсами. Условный рендеринг",
    "idShort": 6,
    "shortLink": "ORNBmRQS"
  },
  {
    "id": "613c802be383b80408691744",
    "name": "Списки и ключи",
    "desc": "###[Списки и ключи](https://learn-reactjs.ru/basics/lists-and-keys)\n###[Состояние компонента](https://ru.reactjs.org/docs/faq-state.html#what-is-the-difference-between-passing-an-object-or-a-function-in-setstate)\n###[Составные компоненты. Поиск в списке](https://metanit.com/web/react/2.8.php)",
    "idShort": 7,
    "shortLink": "fqdBcVkf"
  },
  {
    "id": "613c80e8e289ec24f7c3ee71",
    "name": "Подъём состояния. Композиция компонентов",
    "desc": "###[Подъём состояния выше по иерархии](https://learn-reactjs.ru/basics/lifting-state-up)\n###[Состояние компонента](https://ru.reactjs.org/docs/faq-state.html#what-is-the-difference-between-passing-an-object-or-a-function-in-setstate)\n###[Составные компоненты. Поиск в списке](https://metanit.com/web/react/2.8.php)\n\nОчень часто несколько компонентов должны отражать одни и те же данные, которые меняются с течением времени. В таких случаях следует поднимать состояние выше по иерархии: к их ближайшему общему предку",
    "idShort": 8,
    "shortLink": "obaySp3j"
  },
  {
    "id": "6145d3efa16afd88e180395b",
    "name": "HOC. Refs. Контекст. Формы. Валидация.",
    "desc": "#Внимание!!!\nДля примеров с внешними ссылками на данные!\n>CORS запросы для stackblitz.com из примеров видео не прописаны, а значит могут быть проблемы с получением данных при отправке предполётных запросов",
    "idShort": 9,
    "shortLink": "slnPYD7U"
  },
  {
    "id": "6145d370fc3a143559556cea",
    "name": "Маршрутизация",
    "desc": "[REACT-ROUTER-DOM](https://reactrouter.com/web/guides/quick-start)\n\nnpx create-react-app demo-app\ncd demo-app\nnpm install react-router-dom\n\n```\nimport React from \"react\";\nimport {\n  BrowserRouter as Router,\n  Switch,\n  Route,\n  Link\n} from \"react-router-dom\";\n\nexport default function App() {\n  return (\n    <Router>\n      <div>\n        <nav>\n          <ul>\n            <li>\n              <Link to=\"/\">Home</Link>\n            </li>\n            <li>\n              <Link to=\"/about\">About</Link>\n            </li>\n            <li>\n              <Link to=\"/users\">Users</Link>\n            </li>\n          </ul>\n        </nav>\n\n        {/* A <Switch> looks through its children <Route>s and\n            renders the first one that matches the current URL. */}\n        <Switch>\n          <Route path=\"/about\">\n            <About />\n          </Route>\n          <Route path=\"/users\">\n            <Users />\n          </Route>\n          <Route path=\"/\">\n            <Home />\n          </Route>\n        </Switch>\n      </div>\n    </Router>\n  );\n}\n\nfunction Home() {\n  return <h2>Home</h2>;\n}\n\nfunction About() {\n  return <h2>About</h2>;\n}\n\nfunction Users() {\n  return <h2>Users</h2>;\n}\n```",
    "idShort": 10,
    "shortLink": "7OnCYtLV"
  },
  {
    "id": "614ee3a9483e6922ff36c9eb",
    "name": "Хуки. Основные хуки",
    "desc": "Хук - это функция, которая позволяет создавать или получать доступ к состоянию и жизненному циклу react, в функциональном компоненте.\n\n# Основные хуки\n\n ##  useState\n\n> Возвращает значение с состоянием и функцию для его обновления.\n\n#### Синтаксис\n\n    const [state, setState] = useState(initialState);\n\n#### Входные параметры\n\n    initialState: <any type> - состояние, используемое во время начального рендеринга. \n    Может быть как значением, так и функцией, которая вычисляет начальное состояние\n\n#### Выходные данные\n\n    state: <any type> - значение state\n    setState: <function(state)> - функция обновления состояния\n\n#### Использование\n\n\tfunction Counter({initialCount}) {\n\t  const [count, setCount] = useState(initialCount);\n\t  return (\n\t    <>\n\t      Счёт: {count}\n\t      <button onClick={() => setCount(initialCount)}>Сбросить</button>\n\t      <button onClick={() => setCount(prevCount => prevCount - 1)}>-</button>\n\t      <button onClick={() => setCount(prevCount => prevCount + 1)}>+</button>\n\t    </>\n\t  );\n\t}\n\n## useEffect\n\n> Предназначен для перехвата различного рода изменений в компонентах, которые нельзя обработать внутри компонентов\n\n#### Синтаксис\n\n\tuseEffect(didUpdate [, conditionArgs]);\n\n#### Входные параметры\n\n\tdidUpdate: <function> - Функция, которая выполнится после отрисовки компонента. \n\tТак же она может возвращать функцию, которая выполнится перед удалением компонента.\n\tconditionArgs: array - массив аргументов, при изменении которых будет выполняться хук.\n\n#### Использование\n\n\tuseEffect(\n\t  () => {\n\t    const subscription = props.source.subscribe();\n\t    return () => {\n\t      subscription.unsubscribe();\n\t    };\n\t  },\n\t  [props.source],\n\t);\n\n## useContext\n\n> Принимает объект контекста (значение, возвращённое из `React.createContext`) и возвращает текущее значение контекста для этого контекста. Текущее значение контекста определяется пропсом `value` ближайшего `<MyContext.Provider>` над вызывающим компонентом в дереве.\n\n#### Синтаксис\n\n\tconst value = useContext(MyContext);\n\n#### Входные параметры\n\n\tMyContext: <object> - объект контекста\n\n#### Выходные данные\n\n\tvalue: <any type> - значение, переданное при создании объекта контекста (React.createContext(value))\n\n#### Использование\n\n\tconst themes = {\n\t  light: {\n\t    foreground: \"#000000\",\n\t    background: \"#eeeeee\"\n\t  },\n\t  dark: {\n\t    foreground: \"#ffffff\",\n\t    background: \"#222222\"\n\t  }\n\t};\n\n\tconst ThemeContext = React.createContext(themes.light);\n\n\tfunction App() {\n\t  return (\n\t    <ThemeContext.Provider value={themes.dark}>\n\t      <Toolbar />\n\t    </ThemeContext.Provider>\n\t  );\n\t}\n\n\tfunction Toolbar(props) {\n\t  return (\n\t    <div>\n\t      <ThemedButton />\n\t    </div>\n\t  );\n\t}\n\n\tfunction ThemedButton() {\n\t  const theme = useContext(ThemeContext);  return (    <button style={{ background: theme.background, color: theme.foreground }}>      Я стилизован темой из контекста!    </button>  );\n\t}\n\n# Дополнительные хуки\n\n## useReducer\n\n> Альтернатива для [`useState`](https://ru.reactjs.org/docs/hooks-reference.html#usestate). Принимает редьюсер типа `(state, action) => newState` и возвращает текущее состояние в паре с методом `dispatch`.\n\n#### Синтаксис\n\n\tconst [state, dispatch] = useReducer(reducer, initialArg, init)\n\n#### Входные параметры\n\n\treducer: <function(state, action)> - функция, возвращяющая новое состояние.\n\tinitialArg: <any object> - начальный state\n\tinit: <function(initialCount)> - функция, которя инициализирует state. Так же может применяться для обновления state в reducer.\n\n#### Выходные данные\n\n\tstate: <any object> - значение state\n\tdispatch: <function(action)> - функция, вызывающая reducer и предавая параметры в action\n\n#### Использование\n\n\tconst initialState = {count: 0};\n\n\tfunction reducer(state, action) {\n\t  switch (action.type) {\n\t    case 'increment':\n\t      return {count: state.count + 1};\n\t    case 'decrement':\n\t      return {count: state.count - 1};\n\t    default:\n\t      throw new Error();\n\t  }\n\t}\n\n\tfunction Counter() {\n\t  const [state, dispatch] = useReducer(reducer, initialState);\n\t  return (\n\t    <>\n\t      Count: {state.count}\n\t      <button onClick={() => dispatch({type: 'decrement'})}>-</button>\n\t      <button onClick={() => dispatch({type: 'increment'})}>+</button>\n\t    </>\n\t  );\n\t}\n\n## useCallback\n\n> `useCallback` вернёт мемоизированную версию колбэка, который изменяется только, если изменяются значения одной из зависимостей\n\n#### Синтаксис\n\n\tconst memoizedCallback = useCallback(callback, args)\n\n#### Входные данные\n\tcallback: <function> - колбэк функция\n\targs: <array> - массив зависимостей\n\n#### Выходные данные\n\n\tmemoizedCallback: <function> - мемонизированная версия колбэка\n\n#### Использование\n\n\tconst memoizedCallback = useCallback(\n\t  () => {\n\t    doSomething(a, b);\n\t  },\n\t  [a, b],\n\t);\n\n## useMemo\n\n> Передайте «создающую» функцию и массив зависимостей. `useMemo` будет повторно вычислять мемоизированное значение только тогда, когда значение какой-либо из зависимостей изменилось.\n\n#### Синтаксис\n\n\tconst memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\n\n## useRef\n\n> Возвращает изменяемый ref-объект, свойство `.current` которого инициализируется переданным аргументом (`initialValue`). Возвращённый объект будет сохраняться в течение всего времени жизни компонента.\n\n#### Синтаксис\n\n\tconst refContainer = useRef(initialValue);\n\n#### Входные параметры\n\n\tinitialValue: <any type> - начальное значение ref объекта\n\n####  Выходные параметры\n\n\trefContainer - ссылка на ref-объект\n\n####  Использование\n\n\tfunction TextInputWithFocusButton() {\n\t  const inputEl = useRef(null);\n\t  const onButtonClick = () => {\n\t    // `current` указывает на смонтированный элемент `input`\n\t    inputEl.current.focus();\n\t  };\n\t  return (\n\t    <>\n\t      <input ref={inputEl} type=\"text\" />\n\t      <button onClick={onButtonClick}>Установить фокус на поле ввода</button>\n\t    </>\n\t  );\n\t}\n\n## useImperativeHandle\n\n## useLayoutEffect\n\n## useDebugValue\n",
    "idShort": 11,
    "shortLink": "uo0Ytnmq"
  },
  {
    "id": "614f1f4d18b13b13fb84de57",
    "name": "Введение в Flux и Redux. Дополнительные хуки React",
    "desc": "Хук - это функция, которая позволяет создавать или получать доступ к состоянию и жизненному циклу react, в функциональном компоненте.\n\n# Основные хуки\n\n ##  useState\n\n> Возвращает значение с состоянием и функцию для его обновления.\n\n#### Синтаксис\n\n    const [state, setState] = useState(initialState);\n\n#### Входные параметры\n\n    initialState: <any type> - состояние, используемое во время начального рендеринга. \n    Может быть как значением, так и функцией, которая вычисляет начальное состояние\n\n#### Выходные данные\n\n    state: <any type> - значение state\n    setState: <function(state)> - функция обновления состояния\n\n#### Использование\n\n\tfunction Counter({initialCount}) {\n\t  const [count, setCount] = useState(initialCount);\n\t  return (\n\t    <>\n\t      Счёт: {count}\n\t      <button onClick={() => setCount(initialCount)}>Сбросить</button>\n\t      <button onClick={() => setCount(prevCount => prevCount - 1)}>-</button>\n\t      <button onClick={() => setCount(prevCount => prevCount + 1)}>+</button>\n\t    </>\n\t  );\n\t}\n\n## useEffect\n\n> Предназначен для перехвата различного рода изменений в компонентах, которые нельзя обработать внутри компонентов\n\n#### Синтаксис\n\n\tuseEffect(didUpdate [, conditionArgs]);\n\n#### Входные параметры\n\n\tdidUpdate: <function> - Функция, которая выполнится после отрисовки компонента. \n\tТак же она может возвращать функцию, которая выполнится перед удалением компонента.\n\tconditionArgs: array - массив аргументов, при изменении которых будет выполняться хук.\n\n#### Использование\n\n\tuseEffect(\n\t  () => {\n\t    const subscription = props.source.subscribe();\n\t    return () => {\n\t      subscription.unsubscribe();\n\t    };\n\t  },\n\t  [props.source],\n\t);\n\n## useContext\n\n> Принимает объект контекста (значение, возвращённое из `React.createContext`) и возвращает текущее значение контекста для этого контекста. Текущее значение контекста определяется пропсом `value` ближайшего `<MyContext.Provider>` над вызывающим компонентом в дереве.\n\n#### Синтаксис\n\n\tconst value = useContext(MyContext);\n\n#### Входные параметры\n\n\tMyContext: <object> - объект контекста\n\n#### Выходные данные\n\n\tvalue: <any type> - значение, переданное при создании объекта контекста (React.createContext(value))\n\n#### Использование\n\n\tconst themes = {\n\t  light: {\n\t    foreground: \"#000000\",\n\t    background: \"#eeeeee\"\n\t  },\n\t  dark: {\n\t    foreground: \"#ffffff\",\n\t    background: \"#222222\"\n\t  }\n\t};\n\n\tconst ThemeContext = React.createContext(themes.light);\n\n\tfunction App() {\n\t  return (\n\t    <ThemeContext.Provider value={themes.dark}>\n\t      <Toolbar />\n\t    </ThemeContext.Provider>\n\t  );\n\t}\n\n\tfunction Toolbar(props) {\n\t  return (\n\t    <div>\n\t      <ThemedButton />\n\t    </div>\n\t  );\n\t}\n\n\tfunction ThemedButton() {\n\t  const theme = useContext(ThemeContext);  return (    <button style={{ background: theme.background, color: theme.foreground }}>      Я стилизован темой из контекста!    </button>  );\n\t}\n\n# Дополнительные хуки\n\n## useReducer\n\n> Альтернатива для [`useState`](https://ru.reactjs.org/docs/hooks-reference.html#usestate). Принимает редьюсер типа `(state, action) => newState` и возвращает текущее состояние в паре с методом `dispatch`.\n\n#### Синтаксис\n\n\tconst [state, dispatch] = useReducer(reducer, initialArg, init)\n\n#### Входные параметры\n\n\treducer: <function(state, action)> - функция, возвращяющая новое состояние.\n\tinitialArg: <any object> - начальный state\n\tinit: <function(initialCount)> - функция, которя инициализирует state. Так же может применяться для обновления state в reducer.\n\n#### Выходные данные\n\n\tstate: <any object> - значение state\n\tdispatch: <function(action)> - функция, вызывающая reducer и предавая параметры в action\n\n#### Использование\n\n\tconst initialState = {count: 0};\n\n\tfunction reducer(state, action) {\n\t  switch (action.type) {\n\t    case 'increment':\n\t      return {count: state.count + 1};\n\t    case 'decrement':\n\t      return {count: state.count - 1};\n\t    default:\n\t      throw new Error();\n\t  }\n\t}\n\n\tfunction Counter() {\n\t  const [state, dispatch] = useReducer(reducer, initialState);\n\t  return (\n\t    <>\n\t      Count: {state.count}\n\t      <button onClick={() => dispatch({type: 'decrement'})}>-</button>\n\t      <button onClick={() => dispatch({type: 'increment'})}>+</button>\n\t    </>\n\t  );\n\t}\n\n## useCallback\n\n> `useCallback` вернёт мемоизированную версию колбэка, который изменяется только, если изменяются значения одной из зависимостей\n\n#### Синтаксис\n\n\tconst memoizedCallback = useCallback(callback, args)\n\n#### Входные данные\n\tcallback: <function> - колбэк функция\n\targs: <array> - массив зависимостей\n\n#### Выходные данные\n\n\tmemoizedCallback: <function> - мемонизированная версия колбэка\n\n#### Использование\n\n\tconst memoizedCallback = useCallback(\n\t  () => {\n\t    doSomething(a, b);\n\t  },\n\t  [a, b],\n\t);\n\n## useMemo\n\n> Передайте «создающую» функцию и массив зависимостей. `useMemo` будет повторно вычислять мемоизированное значение только тогда, когда значение какой-либо из зависимостей изменилось.\n\n#### Синтаксис\n\n\tconst memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);\n\n## useRef\n\n> Возвращает изменяемый ref-объект, свойство `.current` которого инициализируется переданным аргументом (`initialValue`). Возвращённый объект будет сохраняться в течение всего времени жизни компонента.\n\n#### Синтаксис\n\n\tconst refContainer = useRef(initialValue);\n\n#### Входные параметры\n\n\tinitialValue: <any type> - начальное значение ref объекта\n\n####  Выходные параметры\n\n\trefContainer - ссылка на ref-объект\n\n####  Использование\n\n\tfunction TextInputWithFocusButton() {\n\t  const inputEl = useRef(null);\n\t  const onButtonClick = () => {\n\t    // `current` указывает на смонтированный элемент `input`\n\t    inputEl.current.focus();\n\t  };\n\t  return (\n\t    <>\n\t      <input ref={inputEl} type=\"text\" />\n\t      <button onClick={onButtonClick}>Установить фокус на поле ввода</button>\n\t    </>\n\t  );\n\t}\n\n## useImperativeHandle\n\n## useLayoutEffect\n\n## useDebugValue\n",
    "idShort": 12,
    "shortLink": "SdgSQ4wj"
  },
  {
    "id": "61504f21a99c5b60f42ce1da",
    "name": "Введение в React Redux",
    "desc": "",
    "idShort": 13,
    "shortLink": "3u4dRhVg"
  },
  {
    "id": "6158609d96d4a65199a2d1e7",
    "name": "Введение в MobX",
    "desc": "#[MobX](https://mobx.js.org/README.html)\n\nПростое масштабируемое управление состоянием.\n\n###Installation\nNPM: `npm install --save mobx`",
    "idShort": 14,
    "shortLink": "yEFN7P1G"
  },
  {
    "id": "615860fc97affc050e4cdc18",
    "name": "Основы тестирования",
    "desc": "#Основы тестирования\n##[Cоздание проекта с тестами](https://create-react-app.dev/docs/getting-started/)\n```\nnpx create-react-app my-test-app\ncd my-test-app\nnpm test\n```\n\n##Дополнения для стандартного функционала тестирования\n\n1. Выполнить команду установки enzyme и адаптера\n```\nnpm i --save-dev jest enzyme @wojtekmaj/enzyme-adapter-react-17\n```\n2. Добавить в файл setupTests.js\n\n```\nimport Enzyme from 'enzyme';\nimport Adapter from '@wojtekmaj/enzyme-adapter-react-17';\n\nEnzyme.configure({ adapter: new Adapter() });\n```\n##Рекомендуемый запуск тестов из проекта\n\n```\nnpm test -- --coverage --watchAll\n```\n\n##Где почитать? Материалы тут:\n\nhttps://create-react-app.dev/docs/running-tests",
    "idShort": 15,
    "shortLink": "obLkreP4"
  },
];
